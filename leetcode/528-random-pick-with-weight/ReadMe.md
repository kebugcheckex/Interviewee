# 528. Random Pick with Weight

[题目链接](https://leetcode.com/problems/random-pick-with-weight/description/)

## 思路

这道题的暴力解法是根据权重，生成对应数量的索引值，然后随机选取。比如权重是 `[2, 3, 4, 1]`, 那么我们就生成一个数组 `[0, 0, 1, 1, 1, 2, 2, 2, 2, 3]`. 下标0的权重是2, 那么我们就产生2个0. 下标1的权重是3, 那么我能就产生3个1. 以此类推。这种方法显然在空间复杂度上是非常糟糕的。

从数学的角度来看，大多数编程语言里默认的随机数生成函数产生的是均匀分布的随机数。我们要实现的功能本质上是把一个均匀分布的随机数映射到一些按照权重比例划分的区间上。比如上一段里的例子对应的区间长度就是 `0.2`, `0.3`, `0.4`, `0.1`. 那么只需要产生`[0, 1)`之间均匀分布的随机数，然后判断落在上述哪一个区间里，即可输出对应区间所指代的下标。

## 实现

### C++

使用C++的标准库函数，可以非常简洁地实现上文描述的思路。首先使用`std::accumulate`计算出权重的总和，然后用`std::transform`计算归一化的权重。之后再用`std::partial_sum`计算累加和。值得一提的是，我们需要在权重数组的最前面插入一个0, 作为起始的边界。如果不这么做，后续实现会需要处理一些额外的边际条件。

有了累加的权重以后，我们用`std::map`结构来存储每个区间上界的值以及该上界左侧的区间对应的下标的值。由于`std::map`采用红黑树对键值进行排序，我们可以使用`upper_bound`函数直接找到某个随机数对应的区间的上界，然后获取它的值，就是题目里需要输出的下标。

具体实现参见代码。

